%include "io64.inc"

section .text
global main
CMAIN:
    mov rbp, rsp; for correct debugging

    PRINT_STRING msg

    ;write your code here
    xor rax, rax
    ret
    
    
    ; 초기화 된 데이터를 사용
    ; [변수 이름] [크기] [초기값]
    ; [크기]: 예약된 키워드 db(define byte, 1byte) dw(2byte), dd(4byte), dq(8byte)
section .data
    ; 아스키코드는 각 문자가 1바이트이며, 마지막에는 널 문자(0x00)가 들어가야한다
    ; msg db 'Hello World', 0x00
    ; 아래 코드도 Hello World , 0x00과 같은 동작을 한다
    ; 즉, 해석기를 이해한 후 동일한 비트만 넣어주면 원하는 동작을 하게 할 수 있다
    msg db 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x00
    
    ; 10진수인 17로 표현해도 같은 결과가 출력된다
    ; 즉, 컴퓨터가 알아들을 수 있는 것은 결국 bit밖에 없다(ON/OFF)
    ; 같은 bit더라도 어떻게 해석하는지에 따라 내용은 달라진다
    a db 0x11, 0x11, 0x11, 0x11
    
    ; 해당 내용을 디버거로 까보면 0x78, 0x56, 0x34, 0x12의 값이 출력된다
    ; 숫자가 메모리에 저장될 때는 두가지 유형(엔디안)이 있다
    ; 1. 그대로 저장(빅 엔디안)
    ; 2. 뒤집어서 저장(리틀 엔디안/ 인텔, AMD에서는 리틀 엔디안으로 저장된다고 생각하면 된다)
    ; 게임의 경우 문제가 생길 수 있다(서버와 클라이언트 엔디안의 비일치)
    ; 이렇게 된 이유? 장단점이 교차한다
    ; - 빅 엔디언: 숫자 비교에 유리
    ;    - 0x12345678, 0x45671234 를 비교한다고 할때, 앞의 1과 4만 비교해도 크기를 알 수 있다
    ;    - 즉 숫자 비교가 더 빠르다
    ; - 리틀 엔디언: 캐스팅에 유리하다
    ;    - 당장 0x12345678의 1바이트가 필요하다고 한다면 리틀 엔디안의 경우 0x100에 저장한 첫번째 바이트를 꺼내오면 된다
    ;    - 하지만 빅엔디안의 경우 0x100이 아닌 0x103에서 1바이트를 꺼내와야 한다, offset 계산 후 꺼내와야해 연산이 많아진다
    ; 
    b dd 0x12345678

    ; 초기화 되지 않은 데이터
    ; [변수 이름] [크기] [개수]
    ; [크기] resb(1byte) resw(2byte) resd(4byte) resq(8byte)
section .bss
    e resb 10